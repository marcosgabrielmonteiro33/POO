# POO
Este projeto em Java consiste em um sistema simples para gerenciamento de demandas, com foco na manipulação de estruturas de dados personalizadas (não prontas do JDK) e na aplicação dos princípios da Programação Orientada a Objetos (POO).

O sistema é composto pelas seguintes classes principais:

Demanda: Representa uma solicitação ou tarefa. Cada Demanda possui atributos como tipo, distâncias (da sede e da equipe), custos (de reparo e impacto), pré-prioridade, prejuízo fiscal e tempo de espera. Um método crucial é calcularPrioridade(), que determina a prioridade da demanda com base em uma fórmula que considera seu tipo e os demais atributos. A classe também sobrescreve os métodos equals() e hashCode() para garantir que objetos Demanda possam ser comparados e manipulados corretamente em coleções, e o método toString() para uma representação textual legível.

TipoDemanda: É uma classe utilitária que define constantes inteiras para os diferentes tipos de demanda (Urgente, Crítico, Normal) e fornece um método estático obterDescricao() para retornar a descrição textual de um tipo de demanda com base em seu valor inteiro.

NoDemanda: Esta é uma classe auxiliar interna à MinhaListaEncadeadaDeDemandas, que representa um nó individual em uma lista encadeada. Cada nó contém uma referência a um objeto Demanda e uma referência ao proximo nó na sequência.

MinhaListaEncadeadaDeDemandas: Esta é a implementação de uma lista encadeada personalizada, criada para demonstrar o gerenciamento de coleções sem utilizar as classes prontas do Java Collections Framework. Ela mantém referências à cabeca (primeiro nó) e à cauda (último nó) para otimizar as operações de adição. Os principais métodos incluem adicionar() (adiciona no final em O(1)), adicionarNoInicio(), remover() (removendo a primeira ocorrência de uma Demanda específica), get() (para acesso por índice, com complexidade O(n)), getTamanho() e estaVazia(). A classe também implementa a interface Iterable, permitindo que suas instâncias sejam percorridas usando o laço for-each do Java, o que melhora o encapsulamento e a legibilidade ao iterar sobre os elementos. Métodos toArray() e fromArray() são fornecidos para facilitar a conversão para e de um array, útil para operações como ordenação externa.

GerenciadorDeDemandas: Esta classe atua como o principal orquestrador das demandas. Ela mantém duas listas encadeadas personalizadas (MinhaListaEncadeadaDeDemandas): demandasEmAndamento e demandasEmEspera. Possui métodos para adicionarDemanda() (direcionando para a fila de andamento ou espera), removerDemanda() (removendo uma demanda específica de uma das filas pelo seu índice), e listarDemandas() (exibindo todas as demandas em ambas as filas). Um método ordenarDemandasEmAndamentoPorPrioridade() é fornecido para classificar as demandas em andamento, que converte a lista para um array, utiliza Arrays.sort (uma ferramenta do JDK para algoritmos de ordenação, mas a lista subjacente é customizada) com um Comparator personalizado, e depois reconstrói a lista encadeada a partir do array ordenado.

Main: Esta é a classe principal que contém o método main() e serve como interface de usuário baseada em console. Ela apresenta um menu interativo que permite ao usuário criar novas demandas, listar demandas existentes e remover demandas. O Main se comunica com o GerenciadorDeDemandas para realizar as operações. Um ponto de melhoria importante no Main é o robusto tratamento de exceções usando blocos try-catch para lidar com InputMismatchException (quando o usuário insere texto em vez de número, por exemplo) e IndexOutOfBoundsException (para índices inválidos durante a remoção), garantindo a estabilidade e a usabilidade do programa.

Em termos de Programação Orientada a Objetos (POO), o código adere aos seguintes princípios:

Abstração: Cada classe representa um conceito bem definido do domínio do problema (Demanda, Gerenciador, Lista, Tipo).
Encapsulamento: Os atributos de todas as classes são privados, e o acesso a eles é controlado por meio de métodos públicos (getters, setters e métodos de comportamento), protegendo o estado interno dos objetos. A implementação da interface Iterable para MinhaListaEncadeadaDeDemandas reforça o encapsulamento ao abstrair os detalhes internos da iteração.
Polimorfismo: É demonstrado pela sobrescrita dos métodos equals(), hashCode() e toString() na classe Demanda, e pelo uso de interfaces funcionais como Comparator (para ordenação) e Iterable (para iteração).
A escolha de implementar MinhaListaEncadeadaDeDemandas manualmente, em vez de usar ArrayList ou PriorityQueue do JDK, demonstra uma compreensão do funcionamento interno dessas estruturas de dados, embora resulte em uma complexidade maior e, em alguns casos, menor eficiência para certas operações (como acesso por índice ou remoção de elemento específico) em comparação com as implementações otimizadas do JDK. No entanto, a adição do ponteiro cauda na lista encadeada melhorou a eficiência da adição de novos elementos para O(1)
